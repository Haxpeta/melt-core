~~~
hello: nice
nice: 2018
data: 2019-03-19 
tag : Note 笔记
~~~
# 树

这个结构和链表(线性表)不同, 最大时间复杂度为$O(log N)$. 这里主要介绍**二叉查找树**.

## 树的定义方法

一个树首先是一些节点的集合

如果集合不为空, 那么它必有一个**根**节点以及`0`个或者多个非空的**子树**组成. 其中每一个子树都被来自根$r$的一条**有向边**链接. 每一棵子树都被称为**根**的**子**(child), 而$r$则是**父**(parent). 没有*子*节点的节点被称为**叶**(leaf), 而具有相同父节点的节点之间互相称做*兄弟*(sibling).

从节点 到 的路径(path)定义为节点的一个序列, ,保证节点为的父节点. 该路径长度为这个节点序列上边的条数. 对于任意一个节点, 它的**深度**为从根节点到该节点的路径的长度. 因此根几点的深度为0. 任意节点的**高**是这个节点到一个**叶**节点最长的**路径长度**(考虑到路径的定义, 这里的叶节点只能是这个节点的子节点). 这里根的高就是整个树的长度, 并且每个树叶就是高0.

如果存在一条从到的路径, 那么是的一位祖先(ancestor), 相反地2是1的后裔(descendant). 如果, 那么为**真**祖先和**真**后裔.

> 这里也意味着根节点既是自己的祖先也是自己的后裔. `zhe是一个code` 而这个是一个**粗体**, 这个是一个_斜体_. > 普通的字符
一个延续, 尽管有了一个换行
这里还是一个换行

断开了, 作为普通的段落处理.
> 不普通的字符


## 数据结构实现

由于每个树的子节点个数不定, 所以最好能够在运行时灵活分配空间. 这里的实现解决方法就是将所有的子节点都放在一个**链表**(线性表)中.

一个典型结构声明为:
```c
typedef vodi * Ele;

typedef 
struct Node {
  Ele Element;
  Node FirstChild;
  Node NextSibling;
} Tree;
```
这里分为两个考虑, 使用`FirstChild`来处理这个节点的子节点链表. 使用`NextSibling`来处理这个节点的兄弟节点链表.

这个就是一般的定义了.

## 遍历策略

`先序遍历`就是先处理该节点, 然后再处理它的子节点.

`后续遍历`就是优先处理该节点的子节点, 然后再处理该节点.

# 二叉树(binary tree)

首先, 它是一个树, 其次, 规定它每个节点的子节点个数不超过2个. 这里将这两个节点命名为`Tnode1`和`Tnode2`. 这两个节点可以任意出现(可以随意消失也可以随意出现). 还有一个是二叉树的优化版本叫做平衡二叉树, 又称为二叉查找树(binary search tree). 它的平均深度为$Olog N$.

## 实现

和树一样, 只不过子节点指针限制为两个指针而已.

## 应用

这里面再介绍一个`中序遍历`. 针对于二叉树. 先处理左节点再处理本身最后处理右节点.


## 搜索树
